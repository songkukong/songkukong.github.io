<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/blog/2023/09/23/%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/"/>
      <url>/blog/2023/09/23/%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一些数学性质"><a href="#一些数学性质" class="headerlink" title="一些数学性质"></a>一些数学性质</h3><p>能被8整除 等价于后三位可以被8整除<br>能被2或5整除 等价于后1位可以被2或5整除<br>能被4整除 等价于后2位可以被4整除<br>能被3或9整除 等价于各位数字之和能被3或9整除<br>能被11整除 等价于奇数位各位数字之和减去偶数维各位数字之和的差值能被11整除<br>能被7 11 13整除 等价于后三位之前的数减去后三位的差值可以被7或11或13整除</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/2023/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2023/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表用数组来表示</p><p>空结点用-1表示</p><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920171746635.png" alt="image-20230920171746635"></p><pre class=" language-c++"><code class="language-c++">/*    head 表示头指针    e[] 表示结点i的值    ne[] 表示结点next的指针    idx 存储当前已经用到的结点*/int head, e[], ne[], idx;//初始化void init()&#123;    head = -1;    idx = 0;&#125;//插入到头结点void add_to_head(int x)&#123;    e[idx] = x;    ne[idx] = head;    head = idx ++;&#125;//将x插入到下表k后面void add(int x, int k)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx ++;&#125;//删除操作void remove(int k)&#123;    ne[k] = ne[ne[k]];&#125;//删除头结点void remove_head()&#123;    head = ne[head];&#125;</code></pre><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><pre class=" language-c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123;    //0是左端点 1是右端点    r[0] = 1, l[1] = 0;    idx = 2;&#125;//结点 a 右边插入一个数xvoid add(int a, int x)&#123;    e[idx] = x;       l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++;&#125;// 删除结点avoid remove(int a)&#123;    l[r[a]] = l[a]; //  1->2->a->3->4  l[r[a]] 表示3   更新a结点右结点的 左指针    r[l[a]] = r[a]; // 更新a左结点的 右指针&#125;</code></pre><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><pre class=" language-C++"><code class="language-C++">//tt表示栈顶int stk[N], tt = 0;//向一个栈中插入元素stk[ ++ t] = x;//从一个栈中弹出一个元素tt --;//取栈顶的值stk[tt];//判断栈是否为空，如果 tt > 0, 则表示为不空if(tt > 0)&#123;    return false;&#125;</code></pre><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><pre class=" language-c++"><code class="language-c++">//hh 表示队头, tt 表示队尾int q[N], hh = 0, tt = 0;//向队尾插入一个元素q[ ++ tt] = x;//从队头弹出一个元素hh ++;//队头的值q[hh];//判断队列是否为空 如果 hh <= tt 则为不空if(hh <= tt)&#123;&#125;</code></pre><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><pre class=" language-c++"><code class="language-c++">//常见的模型： 找出每个数左边离它最近的比它大/小的数int tt = 0;for(int i = 1; i <= n; i ++)&#123;    while(tt && check(stk[tt], i)) tt --;    stk[ ++ tt] = i;&#125;</code></pre><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><pre class=" language-c++"><code class="language-c++">//常见的模型： 滑动窗口中的最大值/最小值for(int i = 0; i < n; i ++)&#123;    if(hh <= tt && check_out(q[hh])) hh ++; //判断队头是否画出窗口    while(hh <= tt && check(q[tt,i])) tt --;    q[ ++ tt] = i;&#125;</code></pre><h4 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h4><pre class=" language-c++"><code class="language-c++">//s[]是长文本, p[]是模式串, n是s串的长度, m是p的长度//求模式串的Next数组for(int i = 2, j = 0; i <= m; i ++)&#123;    while(j && p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++;    ne[i] = j;&#125;//匹配for(int i= 1, j = 0; i <= n; i ++)&#123;    while (j && s[i] != s[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++;    if (j == m)    &#123;        j = ne[j];        //匹配成功后的逻辑    &#125;&#125;</code></pre><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><pre class=" language-c++"><code class="language-c++">/*    0号结点既是根节点 有是空结点    son[][]存储树中每个结点的子节点    cnt[][]存储以每个结点结尾的残次数量*/int son[N][26], cnt[N], idx;//插入一个字符串void insert(char *str)&#123;    int p = 0;    for(int i = 0; str[i]; i ++)    &#123;        int u = str[i] - 'a';        if(!son[p][u]) son[p][u] = ++ idx;        p = s[p][u];    &#125;    cnt[p] ++;&#125;// 查询字符串出现的次数int query(char *str)&#123;    int p = 0;    for(int i = 0; str[i]; i ++)    &#123;        int u = str[i] - 'a';        if(!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    &#125;    return cnt[p];&#125;</code></pre><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>1.两个集合合并</p><p>2.询问两个元素是否在一个集合当中</p><p>基本原理用以棵树来表示。树根的编号就是整个集合的编号，每个节点存储的是他的父节点，p[x]表示x的父节点</p><p>判断树根：if(p[x] &#x3D;&#x3D; x)</p><p>求x集合编号：while(p[x] !&#x3D; x) x &#x3D; p[x];</p><p>合并两集合：px是x的集合编号 ，py是y的集合编号 p[x] &#x3D; y</p><pre class=" language-c++"><code class="language-c++">/*    1.两个集合合并*/int p[N] // 存储每个结点的父类结点 祖父结点int find(int x)&#123;    if(p[x] != x) p[x] = find(x);    return p[x];&#125;//初始化 假设结点编号是 1~nfor(int i = 1; i <= n; i ++) p[i] = i;//两个集合合并p[find(a)] = find(b); //把a的祖宗结点接给了b的祖宗结点 a的祖宗节点变成了b/*    2. 维护size[]    size[N] ----是求每个集合元素的个数    初始化 size[i] = 1*///两个集合合并后的size 例子p[a] = b a集合和b集合合并//有一个特判 集合a 与 集合b 是否本来就是在一个集合当中if(find(a) == find(b)) continue;size[find(b)] += size[find(a)];//(2)维护size的并查集：    int p[N], size[N];    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量    // 返回x的祖宗节点    int find(int x)    &#123;        if (p[x] != x) p[x] = find(p[x]);        return p[x];    &#125;    // 初始化，假定节点编号是1~n    for (int i = 1; i <= n; i ++ )    &#123;        p[i] = i;        size[i] = 1;    &#125;    // 合并a和b所在的两个集合：    size[find(b)] += size[find(a)];    p[find(a)] = find(b);</code></pre><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>是一颗完全二叉树</p><p>小根堆 根节点满足小于等于左右两边的点</p><p>用一个<strong>一维数组来存储</strong> 根结点的索引是1 x结点的左儿子 2x  右儿子 2x+1 </p><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920200011659.png" alt="image-20230920200011659"></p><p>手写一个堆的思路：</p><p>1 插入一个数heap[i ++ size] &#x3D; x  up(size)</p><p>2.就一个集合中的最小值  heap[1]</p><p>3.删除最小值    heap[1] &#x3D; heap[size]   size - down(1)</p><p>4.删除任意一个元素 heap[k] &#x3D; heap[size]   size - down(k) up(k)</p><p>5.修改任意元素 heap[k] &#x3D; x down(k)    up(k)</p><pre class=" language-c++"><code class="language-c++">/*    h[N]  存储堆中的值, h[1]是堆顶， x的左儿子是2x, 右儿子是 2x + 1    ph[k] 存储第k个插入的点在堆中的位置    hp[k] 存储堆中下标是k的点是第几个插入的*/int h[N], ph[N], hp[N], size;//两点交换 及其映射关系void heap_swap(int a, int b)&#123;    swap(ph[a], ph[b]);    swap(hp[a], hp[b]);    sawp(h[a], h[b]);&#125;//down函数void down(int u)&#123;    int t = u;    //判断与左儿子比较    if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2;    //判断与右儿子比较    if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;    if(u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;//up函数void up(int u)&#123;    while(u / 2 && h[u] < h[u / 2])    &#123;        head_swap(u, u / 2);        u >>= 1;    &#125;&#125;//建堆 时间复杂度O(n)for(int i = n / 2; i  i --) down(i);</code></pre><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920201626145.png" alt="image-20230920201626145"></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ol><li>拉链法</li></ol><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920201914443.png" alt="image-20230920201914443"></p><pre class=" language-c++"><code class="language-c++">//1.拉链法int h[N], e[N], ne[N], idx;//向哈希表插入一个数 ----链表的插入void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];//初始化-1  memset(h,-1,sizeof h)    h[k] = idx ++;&#125;//在哈希表中查询 某个数是否存在bool find(int x)&#123;    int k = (x % N + N) % N;    for(int i = h[k]; i != -1; i = ne[i])        if(e[i] == x)            return true;    return false;&#125;</code></pre><ol start="2"><li>开放寻址法</li></ol><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920202558952.png" alt="image-20230920202558952"></p><pre class=" language-c++"><code class="language-c++">//(2)开放寻址法int h[N];//memset(h,03xf,sizeof h) 初始化  null = 0x3f3f3f3f// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123;    int k = (x % N + N) % N;    while(h[k] != null && h[k] != x)    &#123;        k ++;        if(t == N) t = 0;    &#125;    return t;&#125;</code></pre><ol start="3"><li><p>哈希字符串</p><p>字符串前缀哈希法<br><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920203009812.png" alt="image-20230920203009812"></p><p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230920203016473.png" alt="image-20230920203016473"></p></li></ol><pre class=" language-c++"><code class="language-c++">//核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果//快速比较两个字符串的相等也可以typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64//初始化p[0] = 1;for(int i = 1; i <= n; i ++)&#123;    h[i] = h[i - 1] * p + str[i];    p[i] = p[i - 1] * p;&#125;//计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;</code></pre><h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><pre><code>vector, 变长数组，倍增的思想    size()  返回元素个数    empty()  返回是否为空    clear()  清空    front()/back()    push_back()/pop_back()    begin()/end()    []    支持比较运算，按字典序pair&lt;int, int&gt;    first, 第一个元素    second, 第二个元素    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）    可以来存储两个不同的东西 要用的放第一个 不用的发放第二个string，字符串    size()/length()  返回字符串长度    empty()    clear()    substr(起始下标，(子串长度))  返回子串    c_str()  返回字符串所在字符数组的起始地址queue, 队列    size()    empty()    push()  向队尾插入一个元素    front()  返回队头元素    back()  返回队尾元素    pop()  弹出队头元素priority_queue, 优先队列，默认是大根堆    size()    empty()    push()  插入一个元素    top()  返回堆顶元素    pop()  弹出堆顶元素    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈    size()    empty()    push()  向栈顶插入一个元素    top()  返回栈顶元素    pop()  弹出栈顶元素deque, 双端队列    size()    empty()    clear()    front()/back()    push_back()/pop_back()    push_front()/pop_front()    begin()/end()    []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()/end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)    set  不能有重复/multiset   可以有重复        insert()  插入一个数        find()  查找一个数        count()  返回某一个数的个数        erase()            (1) 输入是一个数x，删除所有x   O(k + logn)            (2) 输入一个迭代器，删除这个迭代器        lower_bound()/upper_bound()            lower_bound(x)  返回大于等于x的最小的数的迭代器            upper_bound(x)  返回大于x的最小的数的迭代器    map/multimap        insert()  插入的数是一个pair        erase()  输入的参数是pair或者迭代器        find()        []  注意multimap不支持此操作。 时间复杂度是 O(logn)        lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 压位    bitset&lt;10000&gt; s;    ~, &amp;, |, ^    &gt;&gt;, &lt;&lt;    ==, !=    []    count()  返回有多少个1    any()  判断是否至少有一个1    none()  判断是否全为0    set()  把所有位置成1    set(k, v)  将第k位变成v    reset()  把所有位变成0    flip()  等价于~    flip(k) 把第k位取反</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/2023/09/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2023/09/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h4><p>思路：快速排序——分治</p><p>1.首先应该确定分界点  根据 l r 左右边界 随机赋值给x &#x3D; a[l]  or a[r] or a[(l + r) &#x2F; 2]</p><p>2.开始调整范围 根据你所分的范围 看 i 从前 j从后 看 大于x j–   小于x i ++</p><p>3.递归左右区间</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914171835020.png" alt="image-20230914171835020"></p><pre class=" language-c++"><code class="language-c++">// q[] 要排序的数组  l 起始位置 r最终位置  n-1void quick_sort(int q[],int l,int r)&#123;    if(l >= r) return ;    //定义边界    int x = q[l], i = l - 1, j = r + 1;    while(i < j)    &#123;        do i ++; while(q[i] < x);        do j --; while(q[j] > x);        if(i < j) swap(q[i], q[j]);    &#125;    //递归处理后面左边界 和右边界的    quick_sort(a, l, j);     //第三位要是j 不可以从右边界开始  第三位要是i-1 边界不能从左边界开始    qucik_sort(a, j + 1, r);&#125;</code></pre><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>主要思想 ——分治</p><p>1.确定分界点 mid &#x3D; l + r &gt;&gt; 1</p><p>2.递归左右区间</p><p>3.归并排序 合二为一</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914171928116.png" alt="image-20230914171928116"></p><pre class=" language-c++"><code class="language-c++">void merge_sort(int a[], int l, int r)&#123;    if(l >= r) return ;    //确定分界点    int mid = (i + r) >> 1;    //递归左右区间    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);        //具体归并排序操作     int k = 0, i = l, j = mid + 1;    while(i <= mid && j <= r)    &#123;        if(a[i] < a[j]) tmp[k ++] = a[i ++];        else tmp[k ++] = a[j ++];    &#125;    //假如左区间还存在元素    while(i <= mid) tmp[k ++] = a[i ++];    //假如右区间还存在元素    while(j <= r) tmp[k ++] = a[j ++];    //合二为一 存回原数组中    for(int i = 0; i < n; i++) a[i] = tmp[i];&#125;</code></pre><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><p>前提是一个排好序的数组</p><p>算法思想：1.划分区间点 左右区间来找   区间点一般是mid &#x3D; l + r &gt;&gt; 1</p><p>2.利用一个check(mid)函数来满足我们所需要的  </p><p>3.通过多次 左边界变动  右边界变动 来找到我们需要的值</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914190600030.png" alt="image-20230914190600030"></p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914190608284.png" alt="image-20230914190608284"></p><pre class=" language-c++"><code class="language-c++">bool check(int x)&#123;....&#125; //检查x是否满足某种性质/*对于整数二分来说 q[mid] > x , x的值在左区间 因此要变化有边界 r = mid对于 q[mid] < x , x的值在右区间 因而要变化左边界 l = mid区间[l, r] 被划分为了[l, mid] 和 [mid + 1, r]时使用*///针对与check()函数在[l,mid] ture时候 r = mid 则flase l = mid + 1int bsearch_1(int l, int r)&#123;    while(l < r)    &#123;        int mid = l + r >> 1;        if(check(mid)) r = mid;        else l = mid + 1;    &#125;    return l;&#125;//针对与check()函数在[mid,r] ture时候 l = mid 则flase r = mid - 1int bsearch_2(int l, int r)&#123;    while(l < r)    &#123;        int mid = l + r >> 1;        if(check(mid)) l = mid;        else r = mid - 1;    &#125;    return l;&#125;</code></pre><h4 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h4><pre class=" language-c++"><code class="language-c++">bool check(double x)&#123;...&#125;const double esp = 1e - 6  // eps 表示精度，取决于题目对精度的要求double bsearch(double l, double r)&#123;    while(r - l > 1e - 6)    &#123;        double mid = (l + r) / 2;        if(check(mid)) r = mid//mid*mid >= x        else l = mid;    &#125;    return l;&#125;</code></pre><h4 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h4><pre class=" language-c++"><code class="language-c++">/*    高精度加法是用一个vector数组来存储 C = A + B  A >= 0, B >= 0    数组的每位上的数 就是跟我们现实中做的 列式 加法相同    遍历每一位 相加到另一个数组中 有进位 要进位*/vector <int> add(vector <int> &A, vector<int> &B)&#123;    vector<int>C;    int t = 0; //来存放每位相加的数    for(int i = 0;i < A.size() || i < B.size(); i ++)    &#123;        t += A[i];        t += B[i];        C.push_back(t % 10); //t % 10 取相加后的那个数        t /= 10; //观察是否进位  看进位    &#125;    if(t) C.push_back(1); //进位 +1    return C;&#125;//高精度 比较两个数大小 是否相同bool cmp(vector<int> &A, vector<int> &B)&#123;    if(A.size() != B.size()) return A.size() > B.size();    for(int i = A.size() - 1; i >= 0; i --)        if(A[i] != B[i])            return A[i] > B[i]    return true;&#125;/*    高精度减法 类似与我们笔算减法竖式    同等于高精度加法 用vector来存储      C = A - B  默认的是前者大于后者 满足A >= B, A >= 0, B >= 0*/vector<int> sub(vector<int> &A, vector<int> &B)&#123;    vector<int> C;    for(int i = 0, t = 0; i < A.size(); i ++)    &#123;        t = A[i] - t;        if(i < B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if(t < 0) t = 1; //借位        else t = 0;    &#125;    while(C.size() > 1 && C.back() == 0) C.pop_back(); // 消除高位上的0    return C;&#125;/*    高精度乘低精度 类似与我们笔算乘法竖式    同等于高精度加法 用vector来存储    C = A * b, A >= 0, b >= 0*/vector<int> mul(vector <int> A, int b)&#123;    vector<int> C;    int t = 0;    for(int i = 0; i < A.size() || t; i ++)    &#123;        if(i < A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    while(C.size() > 1 && C.back() == 0) C.pop_back();    return C;&#125;/*    高精度除低精度    A / b = C ... r, A >= 0, b > 0*/vector<int> div(Vector<int> &A, int b)&#123;    vector<int> C;    r = 0;    for(int i = A.size() - 1; i >= 0; i --)    &#123;        r = r * 10 + A[i];        c.push_back(r / b);        r %= b;    &#125;    reverse(C.begin(), C.end());    while(C.size() > 1 && C.back() == 0) C.pop_back();    return C;&#125;</code></pre><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p>对于一个 1 - n 的和 在 区间[l, r]中这段的和可以求出</p><p><code>S[i] = a[1] + a[2] + a[3] + ... + a[i] </code>  或者 </p><p><code>for(int i = 1; i &lt;= n; i ++) s[i] += s[i - 1]</code></p><p><code>a[l] + ... + a[r] = s[r] - s[l - 1]</code></p><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914203631462.png" alt="imgs/image-20230914203631462.png"></p><pre><code>s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j]s[x2, y2] - s[x2, y1 - 1] - s[x1 - 1, y2] + s[x1 - 1, y1 - 1]//求和的for(int i = 1; i &lt;= n; i ++)    for(int j = 1; j &lt;= n; j ++)        s[i,j] += s[i - 1,j] + s[i , j - 1] - s[i - 1, j - 1];S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></pre><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230920171111108.png" alt="image-20230920171111108"></p><p>差分是前缀和的逆</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230920171218834.png" alt="image-20230920171218834"></p><pre class=" language-c++"><code class="language-c++"> b[l] += c b[r+1] -= c</code></pre><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230920171337949.png" alt="image-20230920171337949"></p><pre class=" language-c++"><code class="language-c++">b[x1][y1] += cb[x2+1][y1] -= cb[x1][y2+1] -= cb[x2+1][y2+1] += c</code></pre><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><pre class=" language-c++"><code class="language-c++">//先写一个暴力 O(n^2) 看 i 与 j 的关系是否可以改变for (int i = 0, j = 0; i < n; i ++ )&#123;    while (j < i && check(i, j)) j ++ ;    // 具体问题的逻辑&#125;常见问题分类：    (1) 对于一个序列，用两个指针维护一段区间    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</code></pre><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230920171522640.png" alt="image-20230920171522640"></p><pre class=" language-c++"><code class="language-c++">求n的第k位数字: n >> k & 1返回n的最后一位1：lowbit(n) = n & -n</code></pre><h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><pre class=" language-c++"><code class="language-c++">vector<int> alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123;    int l = 0, r = alls.size() - 1;    while (l < r)    &#123;        int mid = l + r >> 1;        if (alls[mid] >= x) r = mid;        else l = mid + 1;    &#125;    return r + 1; // 映射到1, 2, ...n&#125;</code></pre><h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><pre class=" language-c++"><code class="language-c++">// 将所有存在交集的区间合并void merge(vector<PII> &segs)&#123;    vector<PII> res;    sort(segs.begin(), segs.end());    //给定义的区间    int st = -2e9, ed = -2e9;    //遍历 区间    for (auto seg : segs)        if (ed < seg.first) // 不相交 没有交集 让他们原来的放入即可        &#123;            if (st != -2e9) res.push_back(&#123;st, ed&#125;);            st = seg.first, ed = seg.second;        &#125;        else ed = max(ed, seg.second);//有交集的情况    if (st != -2e9) res.push_back(&#123;st, ed&#125;);    segs = res;    //swap(res, segs);应该效率更高一些，容器交换的时间复杂度是 O(1)，不用再拷贝一次了。&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2023/09/11/hello-world/"/>
      <url>/blog/2023/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
