<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/blog/2023/09/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2023/09/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h5><p>思路：快速排序——分治</p><p>1.首先应该确定分界点  根据 l r 左右边界 随机赋值给x &#x3D; a[l]  or a[r] or a[(l + r) &#x2F; 2]</p><p>2.开始调整范围 根据你所分的范围 看 i 从前 j从后 看 大于x j–   小于x i ++</p><p>3.递归左右区间</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914171835020.png" alt="image-20230914171835020"></p><pre class=" language-c++"><code class="language-c++">// q[] 要排序的数组  l 起始位置 r最终位置  n-1void quick_sort(int q[],int l,int r)&#123;    if(l >= r) return ;    //定义边界    int x = q[l], i = l - 1, j = r + 1;    while(i < j)    &#123;        do i ++; while(q[i] < x);        do j --; while(q[j] > x);        if(i < j) swap(q[i], q[j]);    &#125;    //递归处理后面左边界 和右边界的    quick_sort(a, l, j);     //第三位要是j 不可以从右边界开始  第三位要是i-1 边界不能从左边界开始    qucik_sort(a, j + 1, r);&#125;</code></pre><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>主要思想 ——分治</p><p>1.确定分界点 mid &#x3D; l + r &gt;&gt; 1</p><p>2.递归左右区间</p><p>3.归并排序 合二为一</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914171928116.png" alt="image-20230914171928116"></p><pre class=" language-c++"><code class="language-c++">void merge_sort(int a[], int l, int r)&#123;    if(l >= r) return ;    //确定分界点    int mid = (i + r) >> 1;    //递归左右区间    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);        //具体归并排序操作     int k = 0, i = l, j = mid + 1;    while(i <= mid && j <= r)    &#123;        if(a[i] < a[j]) tmp[k ++] = a[i ++];        else tmp[k ++] = a[j ++];    &#125;    //假如左区间还存在元素    while(i <= mid) tmp[k ++] = a[i ++];    //假如右区间还存在元素    while(j <= r) tmp[k ++] = a[j ++];    //合二为一 存回原数组中    for(int i = 0; i < n; i++) a[i] = tmp[i];&#125;</code></pre><h5 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h5><p>前提是一个排好序的数组</p><p>算法思想：1.划分区间点 左右区间来找   区间点一般是mid &#x3D; l + r &gt;&gt; 1</p><p>2.利用一个check(mid)函数来满足我们所需要的  </p><p>3.通过多次 左边界变动  右边界变动 来找到我们需要的值</p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914190600030.png" alt="image-20230914190600030"></p><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914190608284.png" alt="image-20230914190608284"></p><pre class=" language-c++"><code class="language-c++">bool check(int x)&#123;....&#125; //检查x是否满足某种性质/*对于整数二分来说 q[mid] > x , x的值在左区间 因此要变化有边界 r = mid对于 q[mid] < x , x的值在右区间 因而要变化左边界 l = mid区间[l, r] 被划分为了[l, mid] 和 [mid + 1, r]时使用*///针对与check()函数在[l,mid] ture时候 r = mid 则flase l = mid + 1int bsearch_1(int l, int r)&#123;    while(l < r)    &#123;        int mid = l + r >> 1;        if(check(mid)) r = mid;        else l = mid + 1;    &#125;    return l;&#125;//针对与check()函数在[mid,r] ture时候 l = mid 则flase r = mid - 1int bsearch_2(int l, int r)&#123;    while(l < r)    &#123;        int mid = l + r >> 1;        if(check(mid)) l = mid;        else r = mid - 1;    &#125;    return l;&#125;</code></pre><h5 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h5><pre class=" language-c++"><code class="language-c++">bool check(double x)&#123;...&#125;const double esp = 1e - 6  // eps 表示精度，取决于题目对精度的要求double bsearch(double l, double r)&#123;    while(r - l > 1e - 6)    &#123;        double mid = (l + r) / 2;        if(check(mid)) r = mid//mid*mid >= x        else l = mid;    &#125;    return l;&#125;</code></pre><h5 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h5><pre class=" language-c++"><code class="language-c++">/*    高精度加法是用一个vector数组来存储 C = A + B  A >= 0, B >= 0    数组的每位上的数 就是跟我们现实中做的 列式 加法相同    遍历每一位 相加到另一个数组中 有进位 要进位*/vector <int> add(vector <int> &A, vector<int> &B)&#123;    vector<int>C;    int t = 0; //来存放每位相加的数    for(int i = 0;i < A.size() || i < B.size(); i ++)    &#123;        t += A[i];        t += B[i];        C.push_back(t % 10); //t % 10 取相加后的那个数        t /= 10; //观察是否进位  看进位    &#125;    if(t) C.push_back(1); //进位 +1    return C;&#125;//高精度 比较两个数大小 是否相同bool cmp(vector<int> &A, vector<int> &B)&#123;    if(A.size() != B.size()) return A.size() > B.size();    for(int i = A.size() - 1; i >= 0; i --)        if(A[i] != B[i])            return A[i] > B[i]    return true;&#125;/*    高精度减法 类似与我们笔算减法竖式    同等于高精度加法 用vector来存储      C = A - B  默认的是前者大于后者 满足A >= B, A >= 0, B >= 0*/vector<int> sub(vector<int> &A, vector<int> &B)&#123;    vector<int> C;    for(int i = 0, t = 0; i < A.size(); i ++)    &#123;        t = A[i] - t;        if(i < B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if(t < 0) t = 1; //借位        else t = 0;    &#125;    while(C.size() > 1 && C.back() == 0) C.pop_back(); // 消除高位上的0    return C;&#125;/*    高精度乘低精度 类似与我们笔算乘法竖式    同等于高精度加法 用vector来存储    C = A * b, A >= 0, b >= 0*/vector<int> mul(vector <int> A, int b)&#123;    vector<int> C;    int t = 0;    for(int i = 0; i < A.size() || t; i ++)    &#123;        if(i < A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    while(C.size() > 1 && C.back() == 0) C.pop_back();    return C;&#125;/*    高精度除低精度    A / b = C ... r, A >= 0, b > 0*/vector<int> div(Vector<int> &A, int b)&#123;    vector<int> C;    r = 0;    for(int i = A.size() - 1; i >= 0; i --)    &#123;        r = r * 10 + A[i];        c.push_back(r / b);        r %= b;    &#125;    reverse(C.begin(), C.end());    while(C.size() > 1 && C.back() == 0) C.pop_back();    return C;&#125;</code></pre><h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><p>对于一个 1 - n 的和 在 区间[l, r]中这段的和可以求出</p><p><code>S[i] = a[1] + a[2] + a[3] + ... + a[i] </code>  或者 </p><p><code>for(int i = 1; i &lt;= n; i ++) s[i] += s[i - 1]</code></p><p><code>a[l] + ... + a[r] = s[r] - s[l - 1]</code></p><h5 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h5><p><img src="/blog/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets/image-20230914203631462.png" alt="imgs/image-20230914203631462.png"></p><pre><code>s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j]s[x2, y2] - s[x2, y1 - 1] - s[x1 - 1, y2] + s[x1 - 1, y1 - 1]//求和的for(int i = 1; i &lt;= n; i ++)    for(int j = 1; j &lt;= n; j ++)        s[i,j] += s[i - 1,j] + s[i , j - 1] - s[i - 1, j - 1];S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></pre><h5 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2023/09/11/hello-world/"/>
      <url>/blog/2023/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
